var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { promises as fsPromises } from 'node:fs';
import { parse, resolve } from 'node:path';
import { PDF_TO_PNG_OPTIONS_DEFAULTS } from './const';
import { propsToPdfDocInitParams } from './propsToPdfDocInitParams';
export function pdfToPng(pdfFile, props) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const isBuffer = Buffer.isBuffer(pdfFile);
        const pdfFileBuffer = isBuffer ? pdfFile : (yield fsPromises.readFile(pdfFile)).buffer;
        const pdfDocument = yield getPdfDocument(pdfFileBuffer, props);
        const pagesToProcess = (_a = props === null || props === void 0 ? void 0 : props.pagesToProcess) !== null && _a !== void 0 ? _a : Array.from({ length: pdfDocument.numPages }, (_, index) => index + 1);
        const pngPagesOutput = [];
        try {
            const pngPageOutputs = yield Promise.all(pagesToProcess
                .filter((pageNumber) => pageNumber <= pdfDocument.numPages && pageNumber >= 1)
                .map((pageNumber) => {
                var _a, _b;
                const pageViewportScale = (props === null || props === void 0 ? void 0 : props.viewportScale) !== undefined ? props.viewportScale : PDF_TO_PNG_OPTIONS_DEFAULTS.viewportScale;
                const defaultMask = isBuffer ? PDF_TO_PNG_OPTIONS_DEFAULTS.outputFileMask : parse(pdfFile).name;
                const pageName = (_b = (_a = props === null || props === void 0 ? void 0 : props.outputFileMaskFunc) === null || _a === void 0 ? void 0 : _a.call(props, pageNumber)) !== null && _b !== void 0 ? _b : `${defaultMask}_page_${pageNumber}.png`;
                return processPdfPage(pdfDocument, pageName, pageNumber, pageViewportScale);
            }));
            pngPagesOutput.push(...pngPageOutputs);
        }
        finally {
            yield pdfDocument.cleanup();
        }
        if (props === null || props === void 0 ? void 0 : props.outputFolder) {
            yield fsPromises.mkdir(props.outputFolder, { recursive: true });
            for (const pngPageOutput of pngPagesOutput) {
                pngPageOutput.path = resolve(props.outputFolder, pngPageOutput.name);
                yield fsPromises.writeFile(pngPageOutput.path, pngPageOutput.content);
                pngPageOutput.path = resolve(props.outputFolder, pngPageOutput.name);
            }
        }
        return pngPagesOutput;
    });
}
function getPdfDocument(pdfFileBuffer, props) {
    return __awaiter(this, void 0, void 0, function* () {
        const { getDocument } = yield import('pdfjs-dist/legacy/build/pdf.mjs');
        const documentInitParameters = propsToPdfDocInitParams(props);
        return yield getDocument(Object.assign(Object.assign({}, documentInitParameters), { data: new Uint8Array(pdfFileBuffer) })).promise;
    });
}
function processPdfPage(pdfDocument, pageName, pageNumber, pageViewportScale) {
    return __awaiter(this, void 0, void 0, function* () {
        const page = yield pdfDocument.getPage(pageNumber);
        const viewport = page.getViewport({ scale: pageViewportScale });
        const { canvas, context } = pdfDocument.canvasFactory.create(viewport.width, viewport.height);
        yield page.render({ canvasContext: context, viewport }).promise;
        const pngPageOutput = {
            pageNumber,
            name: pageName,
            content: canvas.toBuffer('image/png'),
            path: '',
            width: viewport.width,
            height: viewport.height,
        };
        page.cleanup();
        return pngPageOutput;
    });
}
